export class AdadeltaOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, rho: any, epsilon: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class AdagradOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, initialAccumulatorValue: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class AdamOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, beta1: any, beta2: any, epsilon: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class AdamaxOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, beta1: any, beta2: any, epsilon: any, decay: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class Callback {
    constructor(...args: any[]);
    onBatchBegin(batch: any, logs: any): any;
    onBatchEnd(batch: any, logs: any): any;
    onEpochBegin(epoch: any, logs: any): any;
    onEpochEnd(epoch: any, logs: any): any;
    onTrainBegin(logs: any): any;
    onTrainEnd(logs: any): any;
    setModel(model: any): void;
    setParams(params: any): void;
}
export class CallbackList {
    constructor(callbacks: any, queueLength: any);
    callbacks: any;
    queueLength: any;
    append(callback: any): void;
    onBatchBegin(batch: any, logs: any): any;
    onBatchEnd(batch: any, logs: any): any;
    onEpochBegin(epoch: any, logs: any): any;
    onEpochEnd(epoch: any, logs: any): any;
    onTrainBegin(logs: any): any;
    onTrainEnd(logs: any): any;
    setModel(model: any): void;
    setParams(params: any): void;
}
export class CustomCallback {
    constructor(args: any);
    onBatchBegin(batch: any, logs: any): any;
    onBatchEnd(batch: any, logs: any): any;
    onEpochBegin(epoch: any, logs: any): any;
    onEpochEnd(epoch: any, logs: any): any;
    onTrainBegin(logs: any): any;
    onTrainEnd(logs: any): any;
    setModel(model: any): void;
    setParams(params: any): void;
}
export class DataStorage {
    constructor(dataMover: any);
    dataMover: any;
    data: any;
    get(dataId: any): any;
    has(dataId: any): any;
    set(dataId: any, value: any): void;
}
export const ENV: {
    backend: any;
    engine: any;
    evaluateFeature: Function;
    features: {
        DEBUG: boolean;
        IS_BROWSER: boolean;
    };
    findBackend: Function;
    get: Function;
    getBestBackendName: Function;
    getFeatures: Function;
    initEngine: Function;
    registerBackend: Function;
    registry: {
        cpu: {
            backend: {
                LRNGrad: any;
                abs: any;
                acos: any;
                acosh: any;
                add: any;
                addN: any;
                all: any;
                any: any;
                argMax: any;
                argMin: any;
                asin: any;
                asinh: any;
                assertNotComplex: any;
                atan: any;
                atan2: any;
                atanh: any;
                avgPool: any;
                avgPoolBackprop: any;
                batchMatMul: any;
                batchNormalization: any;
                batchToSpaceND: any;
                blockSize: any;
                broadcastedBinaryComplexOp: any;
                broadcastedBinaryOp: any;
                cast: any;
                ceil: any;
                clip: any;
                complex: any;
                complexAbs: any;
                concat: any;
                conv2d: any;
                conv2dDerFilter: any;
                conv2dDerInput: any;
                conv3d: any;
                conv3dDerFilter: any;
                conv3dDerInput: any;
                cos: any;
                cosh: any;
                cropAndResize: any;
                cumsum: any;
                data: any;
                depthToSpace: any;
                depthwiseConv2D: any;
                depthwiseConv2DDerFilter: any;
                depthwiseConv2DDerInput: any;
                dispose: any;
                disposeData: any;
                elu: any;
                eluDer: any;
                equal: any;
                erf: any;
                exp: any;
                expm1: any;
                fft: any;
                fftBatch: any;
                fftImpl: any;
                fftRadix2: any;
                firstUse: any;
                floatPrecision: any;
                floor: any;
                floorDiv: any;
                fourierTransformByMatmul: any;
                fromPixels: any;
                fusedBatchMatMul: any;
                gather: any;
                gatherND: any;
                greater: any;
                greaterEqual: any;
                ifft: any;
                imag: any;
                int: any;
                isExponentOf2: any;
                less: any;
                lessEqual: any;
                linear: any;
                localResponseNormalization4D: any;
                log: any;
                log1p: any;
                logicalAnd: any;
                logicalNot: any;
                logicalOr: any;
                max: any;
                maxPool: any;
                maxPoolBackprop: any;
                maxPoolPositions: any;
                maximum: any;
                memory: any;
                min: any;
                minimum: any;
                mod: any;
                multinomial: any;
                multiply: any;
                neg: any;
                nonMaxSuppression: any;
                notEqual: any;
                oneHot: any;
                pad: any;
                pool: any;
                pow: any;
                prelu: any;
                prod: any;
                read: any;
                readSync: any;
                real: any;
                realDivide: any;
                reciprocal: any;
                register: any;
                relu: any;
                reshape: any;
                resizeBilinear: any;
                resizeBilinearBackprop: any;
                resizeNearestNeighbor: any;
                resizeNearestNeighborBackprop: any;
                reverse: any;
                round: any;
                rsqrt: any;
                scatter: any;
                scatterND: any;
                select: any;
                selu: any;
                setDataMover: any;
                sigmoid: any;
                sign: any;
                sin: any;
                sinh: any;
                slice: any;
                softplus: any;
                spaceToBatchND: any;
                sparseToDense: any;
                split: any;
                sqrt: any;
                square: any;
                squaredDifference: any;
                step: any;
                stridedSlice: any;
                subtract: any;
                sum: any;
                tan: any;
                tanh: any;
                tile: any;
                time: any;
                topk: any;
                transpose: any;
                unsortedSegmentSum: any;
                unstack: any;
                where: any;
                write: any;
            };
            priority: number;
        };
    };
    removeBackend: Function;
    reset: Function;
    set: Function;
    setFeatures: Function;
};
export class Environment {
    static dispose(container: any): void;
    static disposeVariables(): void;
    static getBackend(): any;
    static keep(result: any): any;
    static memory(): any;
    static profile(f: any): any;
    static setBackend(backendName: any, safeMode: any): void;
    static tidy(nameOrFn: any, fn: any): any;
    static time(f: any): any;
    constructor(features: any);
    features: any;
    registry: any;
    evaluateFeature(feature: any): any;
    findBackend(name: any): any;
    get(feature: any): any;
    getBestBackendName(): any;
    getFeatures(): any;
    initEngine(): void;
    registerBackend(name: any, factory: any, priority: any, setTensorTrackerFn: any): any;
    removeBackend(name: any): void;
    reset(): void;
    set(feature: any, value: any): void;
    setFeatures(features: any): void;
}
export class FrozenModel {
    constructor(modelUrl: any, weightManifestUrl: any, requestOption: any, weightPrefix: any, onProgress: any);
    modelUrl: any;
    weightManifestUrl: any;
    requestOption: any;
    weightPrefix: any;
    onProgress: any;
    version: any;
    constructTensorMap(inputs: any): any;
    convertTensorMapToTensorsMap(map: any): any;
    dispose(): void;
    execute(inputs: any, outputs: any): any;
    executeAsync(inputs: any, outputs: any): any;
    execute_(inputs: any, strictInputCheck: any, outputs: any): any;
    findIOHandler(): void;
    load(): any;
    predict(inputs: any, config: any): any;
}
export class FrozenModelJSON {
    constructor(modelUrl: any, requestOption: any, weightPrefix: any, onProgress: any);
    modelUrl: any;
    requestOption: any;
    weightPrefix: any;
    onProgress: any;
    version: any;
    constructTensorMap(inputs: any): any;
    convertTensorMapToTensorsMap(map: any): any;
    dispose(): void;
    execute(inputs: any, outputs: any): any;
    executeAsync(inputs: any, outputs: any): any;
    execute_(inputs: any, strictInputCheck: any, outputs: any): any;
    findIOHandler(): void;
    load(): any;
    predict(inputs: any, config: any): any;
}
export class GraphModel {
    constructor(modelUrl: any, weightManifestUrl: any, requestOption: any, weightPrefix: any, onProgress: any);
    modelUrl: any;
    weightManifestUrl: any;
    requestOption: any;
    weightPrefix: any;
    onProgress: any;
    version: any;
    constructTensorMap(inputs: any): any;
    convertTensorMapToTensorsMap(map: any): any;
    dispose(): void;
    execute(inputs: any, outputs: any): any;
    executeAsync(inputs: any, outputs: any): any;
    execute_(inputs: any, strictInputCheck: any, outputs: any): any;
    findIOHandler(): void;
    load(): any;
    predict(inputs: any, config: any): any;
}
export class History {
    constructor(...args: any[]);
    onBatchBegin(batch: any, logs: any): any;
    onBatchEnd(batch: any, logs: any): any;
    onEpochBegin(epoch: any, logs: any): any;
    onEpochEnd(epoch: any, logs: any): any;
    onTrainBegin(logs: any): any;
    onTrainEnd(logs: any): any;
    setModel(model: any): void;
    setParams(params: any): void;
    syncData(): any;
}
export class InputSpec {
    constructor(args: any);
    dtype: any;
    shape: any;
    ndim: any;
    maxNDim: any;
    minNDim: any;
    axes: any;
}
export class KernelBackend {
    LRNGrad(dy: any, inputImage: any, outputImage: any, radius: any, bias: any, alpha: any, beta: any): void;
    abs(x: any): void;
    acos(x: any): void;
    acosh(x: any): void;
    add(a: any, b: any): void;
    addN(tensors: any): void;
    all(x: any, axes: any): void;
    any(x: any, axes: any): void;
    argMax(x: any, axis: any): void;
    argMin(x: any, axis: any): void;
    asin(x: any): void;
    asinh(x: any): void;
    atan(x: any): void;
    atan2(a: any, b: any): void;
    atanh(x: any): void;
    avgPool(x: any, convInfo: any): void;
    avgPoolBackprop(dy: any, x: any, convInfo: any): void;
    batchMatMul(a: any, b: any, transposeA: any, transposeB: any): void;
    batchNormalization(x: any, mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): void;
    batchToSpaceND(x: any, blockShape: any, crops: any): void;
    cast(x: any, dtype: any): void;
    ceil(x: any): void;
    clip(x: any, min: any, max: any): void;
    complex(real: any, imag: any): void;
    complexAbs(x: any): void;
    concat(tensors: any, axis: any): void;
    conv2d(x: any, filter: any, convInfo: any): void;
    conv2dDerFilter(x: any, dY: any, convInfo: any): void;
    conv2dDerInput(dy: any, filter: any, convInfo: any): void;
    conv3d(x: any, filter: any, convInfo: any): void;
    conv3dDerFilter(x: any, dY: any, convInfo: any): void;
    conv3dDerInput(dy: any, filter: any, convInfo: any): void;
    cos(x: any): void;
    cosh(x: any): void;
    cropAndResize(image: any, boxes: any, boxIndex: any, cropSize: any, method: any, extrapolationValue: any): void;
    cumsum(x: any, axis: any, exclusive: any, reverse: any): void;
    depthToSpace(x: any, blockSize: any, dataFormat: any): void;
    depthwiseConv2D(input: any, filter: any, convInfo: any): void;
    depthwiseConv2DDerFilter(x: any, dY: any, convInfo: any): void;
    depthwiseConv2DDerInput(dy: any, filter: any, convInfo: any): void;
    dispose(): void;
    disposeData(dataId: any): void;
    elu(x: any): void;
    eluDer(dy: any, y: any): void;
    equal(a: any, b: any): void;
    erf(x: any): void;
    exp(x: any): void;
    expm1(x: any): void;
    fft(x: any): void;
    floatPrecision(): void;
    floor(x: any): void;
    floorDiv(a: any, b: any): void;
    fromPixels(pixels: any, numChannels: any): void;
    fusedBatchMatMul(a: any, b: any, transposeA: any, transposeB: any, bias: any, activation: any): void;
    gather(x: any, indices: any, axis: any): void;
    gatherND(x: any, indices: any): void;
    greater(a: any, b: any): void;
    greaterEqual(a: any, b: any): void;
    ifft(x: any): void;
    imag(input: any): void;
    int(x: any): void;
    less(a: any, b: any): void;
    lessEqual(a: any, b: any): void;
    localResponseNormalization4D(x: any, radius: any, bias: any, alpha: any, beta: any): void;
    log(x: any): void;
    log1p(x: any): void;
    logicalAnd(a: any, b: any): void;
    logicalNot(a: any): void;
    logicalOr(a: any, b: any): void;
    max(x: any, axes: any): void;
    maxPool(x: any, convInfo: any): void;
    maxPoolBackprop(dy: any, x: any, y: any, convInfo: any): void;
    maximum(a: any, b: any): void;
    memory(): void;
    min(x: any, axes: any): void;
    minimum(a: any, b: any): void;
    mod(a: any, b: any): void;
    multinomial(logits: any, normalized: any, numSamples: any, seed: any): void;
    multiply(a: any, b: any): void;
    neg(a: any): void;
    nonMaxSuppression(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): void;
    notEqual(a: any, b: any): void;
    oneHot(indices: any, depth: any, onValue: any, offValue: any): void;
    pad(x: any, paddings: any, constantValue: any): void;
    pow(a: any, b: any): void;
    prelu(x: any, a: any): void;
    prod(x: any, axes: any): void;
    read(dataId: any): void;
    readSync(dataId: any): void;
    real(input: any): void;
    realDivide(a: any, b: any): void;
    reciprocal(x: any): void;
    register(dataId: any, shape: any, dtype: any): void;
    relu(x: any): void;
    reshape(x: any, shape: any): void;
    resizeBilinear(x: any, newHeight: any, newWidth: any, alignCorners: any): void;
    resizeBilinearBackprop(dy: any, x: any, alignCorners: any): void;
    resizeNearestNeighbor(x: any, newHEight: any, newWidth: any, alignCorners: any): void;
    resizeNearestNeighborBackprop(dy: any, x: any, alignCorners: any): void;
    reverse(a: any, axis: any): void;
    round(x: any): void;
    rsqrt(x: any): void;
    scatterND(indices: any, updates: any, shape: any): void;
    select(condition: any, a: any, b: any): void;
    selu(x: any): void;
    setDataMover(dataMover: any): void;
    sigmoid(x: any): void;
    sign(x: any): void;
    sin(x: any): void;
    sinh(x: any): void;
    slice(x: any, begin: any, size: any): void;
    softplus(x: any): void;
    spaceToBatchND(x: any, blockShape: any, paddings: any): void;
    sparseToDense(sparseIndices: any, sparseValues: any, outputShape: any, defaultValue: any): void;
    split(value: any, sizeSplits: any, axis: any): void;
    sqrt(x: any): void;
    square(x: any): void;
    squaredDifference(a: any, b: any): void;
    step(x: any, alpha: any): void;
    stridedSlice(x: any, begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): void;
    subtract(a: any, b: any): void;
    sum(x: any, axes: any): void;
    tan(x: any): void;
    tanh(x: any): void;
    tile(x: any, reps: any): void;
    time(f: any): void;
    topk(x: any, k: any, sorted: any): void;
    transpose(x: any, perm: any): void;
    unsortedSegmentSum(x: any, segmentIds: any, numSegments: any): void;
    unstack(x: any, axis: any): void;
    where(condition: any): void;
    write(dataId: any, values: any): void;
}
export class LayerVariable {
    constructor(val: any, dtype: any, name: any, trainable: any, constraint: any);
    dtype: any;
    shape: any;
    id: any;
    originalName: any;
    name: any;
    trainable: any;
    constraint: any;
    val: any;
    assertNotDisposed(): void;
    dispose(): void;
    read(): any;
    write(newVal: any): any;
}
export class Model {
    static className: string;
    static fromConfig(cls: any, config: any, customObjects: any, fastWeightInit: any): any;
    static nodeKey(layer: any, nodeIndex: any): any;
    constructor(args: any);
    addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
    addLoss(losses: any): void;
    addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
    apply(inputs: any, kwargs: any): any;
    assertInputCompatibility(inputs: any): void;
    assertNotDisposed(): void;
    build(inputShape: any): void;
    buildNodeConversionMap(layers: any): any;
    calculateLosses(): any;
    call(inputs: any, kwargs: any): any;
    checkNumSamples(ins: any, batchSize: any, steps: any, stepsName: any): any;
    checkTrainableWeightsConsistency(): void;
    clearCallHook(): void;
    compile(args: any): void;
    computeMask(inputs: any, mask: any): any;
    computeOutputShape(inputShape: any): any;
    countParams(): any;
    dispose(): any;
    disposeWeights(): any;
    evaluate(x: any, y: any, args: any): any;
    evaluateDataset(dataset: any, args: any): any;
    execute(inputs: any, outputs: any): any;
    fit(x: any, y: any, args: any): any;
    fitDataset(dataset: any, args: any): any;
    getClassName(): any;
    getConfig(): any;
    getDedupedMetricsNames(): any;
    getInputAt(nodeIndex: any): any;
    getLayer(name: any, index: any): any;
    getNamedWeights(config: any): any;
    getNodeAtIndex(nodeIndex: any, attrName: any): any;
    getOutputAt(nodeIndex: any): any;
    getWeights(trainableOnly: any): any;
    invokeCallHook(inputs: any, kwargs: any): void;
    loadWeights(weightsJSON: any, skipMismatch: any, isNamedTensorMap: any, strict: any): void;
    makeTestFunction(): void;
    makeTrainFunction(): any;
    predict(x: any, args: any): any;
    predictLoop(ins: any, batchSize: any, verbose: any): any;
    predictOnBatch(x: any): any;
    resetStates(): void;
    retrieveSymbolicTensors(symbolicTensorNames: any): any;
    runInternalGraph(inputs: any, masks: any): any;
    save(handlerOrURL: any, config: any): any;
    setCallHook(callHook: any): void;
    setFastWeightInitDuringBuild(value: any): void;
    setWeights(weights: any): void;
    standardizeUserData(x: any, y: any, checkBatchAxis: any, batchSize: any): any;
    summary(lineLength: any, positions: any, printFn: any): void;
    testLoop(f: any, ins: any, batchSize: any, verbose: any, steps: any): any;
    toJSON(unused: any, returnString: any): any;
    trainOnBatch(x: any, y: any): any;
    updatedConfig(): any;
    warnOnIncompatibleInputShape(inputShape: any): void;
}
export class MomentumOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, momentum: any, useNesterov: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
    setLearningRate(learningRate: any): void;
    setMomentum(momentum: any): void;
}
export class Optimizer {
    static fromConfig(cls: any, config: any): any;
    constructor(...args: any[]);
    computeGradients(f: any, varList: any): any;
    getClassName(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class RMSPropOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any, decay: any, momentum: any, epsilon: any, centered: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
}
export class RNN {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    static nodeKey(layer: any, nodeIndex: any): any;
    constructor(args: any);
    addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
    addLoss(losses: any): void;
    addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
    apply(inputs: any, kwargs: any): any;
    assertInputCompatibility(inputs: any): void;
    assertNotDisposed(): void;
    build(inputShape: any): void;
    calculateLosses(): any;
    call(inputs: any, kwargs: any): any;
    clearCallHook(): void;
    computeMask(inputs: any, mask: any): any;
    computeOutputShape(inputShape: any): any;
    countParams(): any;
    dispose(): any;
    disposeWeights(): any;
    getClassName(): any;
    getConfig(): any;
    getInitialState(inputs: any): any;
    getInputAt(nodeIndex: any): any;
    getNodeAtIndex(nodeIndex: any, attrName: any): any;
    getOutputAt(nodeIndex: any): any;
    getStates(): any;
    getWeights(trainableOnly: any): any;
    invokeCallHook(inputs: any, kwargs: any): void;
    resetStates(states: any, training: any): void;
    setCallHook(callHook: any): void;
    setFastWeightInitDuringBuild(value: any): void;
    setStates(states: any): void;
    setWeights(weights: any): void;
    warnOnIncompatibleInputShape(inputShape: any): void;
}
export const Rank: {
    R0: string;
    R1: string;
    R2: string;
    R3: string;
    R4: string;
    R5: string;
    R6: string;
};
export const Reduction: {
    "0": string;
    "1": string;
    "2": string;
    "3": string;
    MEAN: number;
    NONE: number;
    SUM: number;
    SUM_BY_NONZERO_WEIGHTS: number;
};
export class SGDOptimizer {
    static className: string;
    static fromConfig(cls: any, config: any): any;
    constructor(learningRate: any);
    applyGradients(variableGradients: any): void;
    computeGradients(f: any, varList: any): any;
    dispose(): void;
    getClassName(): any;
    getConfig(): any;
    minimize(f: any, returnCost: any, varList: any): any;
    setLearningRate(learningRate: any): void;
}
export class Sequential {
    static className: string;
    static fromConfig(cls: any, config: any, customObjects: any, fastWeightInit: any): any;
    static nodeKey(layer: any, nodeIndex: any): any;
    constructor(args: any);
    add(layer: any): void;
    addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
    addLoss(losses: any): void;
    addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
    apply(inputs: any, kwargs: any): any;
    assertInputCompatibility(inputs: any): void;
    assertNotDisposed(): void;
    build(inputShape: any): void;
    buildNodeConversionMap(layers: any): any;
    calculateLosses(): any;
    call(inputs: any, kwargs: any): any;
    checkNumSamples(ins: any, batchSize: any, steps: any, stepsName: any): any;
    checkShape(layer: any): void;
    checkTrainableWeightsConsistency(): void;
    clearCallHook(): void;
    compile(args: any): void;
    computeMask(inputs: any, mask: any): any;
    computeOutputShape(inputShape: any): any;
    countParams(): any;
    dispose(): any;
    disposeWeights(): any;
    evaluate(x: any, y: any, args: any): any;
    evaluateDataset(dataset: any, args: any): any;
    execute(inputs: any, outputs: any): any;
    fit(x: any, y: any, args: any): any;
    fitDataset(dataset: any, args: any): any;
    getClassName(): any;
    getConfig(): any;
    getDedupedMetricsNames(): any;
    getInputAt(nodeIndex: any): any;
    getLayer(name: any, index: any): any;
    getNamedWeights(config: any): any;
    getNodeAtIndex(nodeIndex: any, attrName: any): any;
    getOutputAt(nodeIndex: any): any;
    getWeights(trainableOnly: any): any;
    invokeCallHook(inputs: any, kwargs: any): void;
    loadWeights(weightsJSON: any, skipMismatch: any, isNamedTensorMap: any, strict: any): void;
    makeTestFunction(): void;
    makeTrainFunction(): any;
    pop(): void;
    predict(x: any, args: any): any;
    predictLoop(ins: any, batchSize: any, verbose: any): any;
    predictOnBatch(x: any): any;
    resetStates(): void;
    retrieveSymbolicTensors(symbolicTensorNames: any): any;
    runInternalGraph(inputs: any, masks: any): any;
    save(handlerOrURL: any, config: any): any;
    setCallHook(callHook: any): void;
    setFastWeightInitDuringBuild(value: any): void;
    setWeights(weights: any): void;
    standardizeUserData(x: any, y: any, checkBatchAxis: any, batchSize: any): any;
    summary(lineLength: any, positions: any, printFn: any): void;
    testLoop(f: any, ins: any, batchSize: any, verbose: any, steps: any): any;
    toJSON(unused: any, returnString: any): any;
    trainOnBatch(x: any, y: any): any;
    updatedConfig(): any;
    warnOnIncompatibleInputShape(inputShape: any): void;
}
export class SymbolicTensor {
    constructor(dtype: any, shape: any, sourceLayer: any, inputs: any, callArgs: any, name: any, outputTensorIndex: any);
    dtype: any;
    shape: any;
    sourceLayer: any;
    inputs: any;
    callArgs: any;
    outputTensorIndex: any;
    id: any;
    originalName: any;
    name: any;
    rank: any;
}
export class Tensor {
    static make(shape: any, data: any, dtype: any): any;
    constructor(shape: any, dtype: any, values: any, dataId: any);
    isDisposedInternal: any;
    shape: any;
    dtype: any;
    size: any;
    strides: any;
    dataId: any;
    id: any;
    rankType: any;
    abs(): any;
    acos(): any;
    acosh(): any;
    add(x: any): any;
    addStrict(x: any): any;
    all(axis: any, keepDims: any): any;
    any(axis: any, keepDims: any): any;
    argMax(axis: any): any;
    argMin(axis: any): any;
    array(): any;
    arraySync(): any;
    as1D(): any;
    as2D(rows: any, columns: any): any;
    as3D(rows: any, columns: any, depth: any): any;
    as4D(rows: any, columns: any, depth: any, depth2: any): any;
    as5D(rows: any, columns: any, depth: any, depth2: any, depth3: any): any;
    asScalar(): any;
    asType(dtype: any): any;
    asin(): any;
    asinh(): any;
    atan(): any;
    atan2(x: any): any;
    atanh(): any;
    avgPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
    batchNorm(mean: any, variance: any, offset: any, scale: any, varianceEpsilon: any): any;
    batchNormalization(mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
    batchToSpaceND(blockShape: any, crops: any): any;
    buffer(): any;
    bufferSync(): any;
    cast(dtype: any): any;
    ceil(): any;
    clipByValue(min: any, max: any): any;
    clone(): any;
    concat(x: any, axis: any): any;
    conv1d(filter: any, stride: any, pad: any, dataFormat: any, dilation: any, dimRoundingMode: any): any;
    conv2d(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
    conv2dTranspose(filter: any, outputShape: any, strides: any, pad: any, dimRoundingMode: any): any;
    cos(): any;
    cosh(): any;
    cumsum(axis: any, exclusive: any, reverse: any): any;
    data(): any;
    dataSync(): any;
    depthToSpace(blockSize: any, dataFormat: any): any;
    depthwiseConv2D(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
    dispose(): void;
    div(x: any): any;
    divStrict(x: any): any;
    dot(b: any): any;
    elu(): any;
    equal(x: any): any;
    equalStrict(x: any): any;
    erf(): any;
    exp(): any;
    expandDims(axis: any): any;
    expm1(): any;
    fft(): any;
    flatten(): any;
    floor(): any;
    floorDiv(x: any): any;
    gather(indices: any, axis: any): any;
    get(...args: any[]): any;
    greater(x: any): any;
    greaterEqual(x: any): any;
    greaterEqualStrict(x: any): any;
    greaterStrict(x: any): any;
    ifft(): any;
    irfft(): any;
    leakyRelu(alpha: any): any;
    less(x: any): any;
    lessEqual(x: any): any;
    lessEqualStrict(x: any): any;
    lessStrict(x: any): any;
    localResponseNormalization(radius: any, bias: any, alpha: any, beta: any): any;
    log(): any;
    log1p(): any;
    logSigmoid(): any;
    logSoftmax(axis: any): any;
    logSumExp(axis: any, keepDims: any): any;
    logicalAnd(x: any): any;
    logicalNot(): any;
    logicalOr(x: any): any;
    logicalXor(x: any): any;
    matMul(b: any, transposeA: any, transposeB: any): any;
    max(axis: any, keepDims: any): any;
    maxPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
    maximum(x: any): any;
    maximumStrict(x: any): any;
    mean(axis: any, keepDims: any): any;
    min(axis: any, keepDims: any): any;
    minimum(x: any): any;
    minimumStrict(x: any): any;
    mod(x: any): any;
    modStrict(x: any): any;
    mul(x: any): any;
    mulStrict(x: any): any;
    neg(): any;
    norm(ord: any, axis: any, keepDims: any): any;
    notEqual(x: any): any;
    notEqualStrict(x: any): any;
    oneHot(depth: any, onValue: any, offValue: any): any;
    onesLike(): any;
    pad(paddings: any, constantValue: any): any;
    pool(windowShape: any, poolingType: any, padding: any, dilationRate: any, strides: any): any;
    pow(exp: any): any;
    powStrict(exp: any): any;
    prelu(alpha: any): any;
    print(verbose: any): any;
    prod(axis: any, keepDims: any): any;
    reciprocal(): any;
    relu(): any;
    reshape(newShape: any): any;
    reshapeAs(x: any): any;
    resizeBilinear(newShape2D: any, alignCorners: any): any;
    resizeNearestNeighbor(newShape2D: any, alignCorners: any): any;
    reverse(axis: any): any;
    rfft(): any;
    round(): any;
    rsqrt(): any;
    selu(): any;
    separableConv2d(depthwiseFilter: any, pointwiseFilter: any, strides: any, pad: any, dilation: any, dataFormat: any): any;
    sigmoid(): any;
    sign(): any;
    sin(): any;
    sinh(): any;
    slice(begin: any, size: any): any;
    softmax(dim: any): any;
    softplus(): any;
    spaceToBatchND(blockShape: any, paddings: any): any;
    split(numOrSizeSplits: any, axis: any): any;
    sqrt(): any;
    square(): any;
    squaredDifference(x: any): any;
    squaredDifferenceStrict(x: any): any;
    squeeze(axis: any): any;
    stack(x: any, axis: any): any;
    step(alpha: any): any;
    stridedSlice(begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
    sub(x: any): any;
    subStrict(x: any): any;
    sum(axis: any, keepDims: any): any;
    tan(): any;
    tanh(): any;
    throwIfDisposed(): void;
    tile(reps: any): any;
    toBool(): any;
    toFloat(): any;
    toInt(): any;
    toString(verbose: any): any;
    topk(k: any, sorted: any): any;
    transpose(perm: any): any;
    unsortedSegmentSum(segmentIds: any, numSegments: any): any;
    unstack(axis: any): any;
    variable(trainable: any, name: any, dtype: any): any;
    where(condition: any, x: any): any;
    zerosLike(): any;
}
export class TensorBuffer {
    constructor(shape: any, dtype: any, values: any);
    dtype: any;
    shape: any;
    size: any;
    values: any;
    strides: any;
    get(...args: any[]): any;
    indexToLoc(index: any): any;
    locToIndex(locs: any): any;
    set(value: any, ...args: any[]): void;
    toTensor(): any;
}
export class Variable {
    static make(shape: any, data: any, dtype: any): any;
    static variable(initialValue: any, trainable: any, name: any, dtype: any): any;
    constructor(initialValue: any, trainable: any, name: any);
    abs(): any;
    acos(): any;
    acosh(): any;
    add(x: any): any;
    addStrict(x: any): any;
    all(axis: any, keepDims: any): any;
    any(axis: any, keepDims: any): any;
    argMax(axis: any): any;
    argMin(axis: any): any;
    array(): any;
    arraySync(): any;
    as1D(): any;
    as2D(rows: any, columns: any): any;
    as3D(rows: any, columns: any, depth: any): any;
    as4D(rows: any, columns: any, depth: any, depth2: any): any;
    as5D(rows: any, columns: any, depth: any, depth2: any, depth3: any): any;
    asScalar(): any;
    asType(dtype: any): any;
    asin(): any;
    asinh(): any;
    assign(newValue: any): void;
    atan(): any;
    atan2(x: any): any;
    atanh(): any;
    avgPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
    batchNorm(mean: any, variance: any, offset: any, scale: any, varianceEpsilon: any): any;
    batchNormalization(mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
    batchToSpaceND(blockShape: any, crops: any): any;
    buffer(): any;
    bufferSync(): any;
    cast(dtype: any): any;
    ceil(): any;
    clipByValue(min: any, max: any): any;
    clone(): any;
    concat(x: any, axis: any): any;
    conv1d(filter: any, stride: any, pad: any, dataFormat: any, dilation: any, dimRoundingMode: any): any;
    conv2d(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
    conv2dTranspose(filter: any, outputShape: any, strides: any, pad: any, dimRoundingMode: any): any;
    cos(): any;
    cosh(): any;
    cumsum(axis: any, exclusive: any, reverse: any): any;
    data(): any;
    dataSync(): any;
    depthToSpace(blockSize: any, dataFormat: any): any;
    depthwiseConv2D(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
    dispose(): void;
    div(x: any): any;
    divStrict(x: any): any;
    dot(b: any): any;
    elu(): any;
    equal(x: any): any;
    equalStrict(x: any): any;
    erf(): any;
    exp(): any;
    expandDims(axis: any): any;
    expm1(): any;
    fft(): any;
    flatten(): any;
    floor(): any;
    floorDiv(x: any): any;
    gather(indices: any, axis: any): any;
    get(...args: any[]): any;
    greater(x: any): any;
    greaterEqual(x: any): any;
    greaterEqualStrict(x: any): any;
    greaterStrict(x: any): any;
    ifft(): any;
    irfft(): any;
    leakyRelu(alpha: any): any;
    less(x: any): any;
    lessEqual(x: any): any;
    lessEqualStrict(x: any): any;
    lessStrict(x: any): any;
    localResponseNormalization(radius: any, bias: any, alpha: any, beta: any): any;
    log(): any;
    log1p(): any;
    logSigmoid(): any;
    logSoftmax(axis: any): any;
    logSumExp(axis: any, keepDims: any): any;
    logicalAnd(x: any): any;
    logicalNot(): any;
    logicalOr(x: any): any;
    logicalXor(x: any): any;
    matMul(b: any, transposeA: any, transposeB: any): any;
    max(axis: any, keepDims: any): any;
    maxPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
    maximum(x: any): any;
    maximumStrict(x: any): any;
    mean(axis: any, keepDims: any): any;
    min(axis: any, keepDims: any): any;
    minimum(x: any): any;
    minimumStrict(x: any): any;
    mod(x: any): any;
    modStrict(x: any): any;
    mul(x: any): any;
    mulStrict(x: any): any;
    neg(): any;
    norm(ord: any, axis: any, keepDims: any): any;
    notEqual(x: any): any;
    notEqualStrict(x: any): any;
    oneHot(depth: any, onValue: any, offValue: any): any;
    onesLike(): any;
    pad(paddings: any, constantValue: any): any;
    pool(windowShape: any, poolingType: any, padding: any, dilationRate: any, strides: any): any;
    pow(exp: any): any;
    powStrict(exp: any): any;
    prelu(alpha: any): any;
    print(verbose: any): any;
    prod(axis: any, keepDims: any): any;
    reciprocal(): any;
    relu(): any;
    reshape(newShape: any): any;
    reshapeAs(x: any): any;
    resizeBilinear(newShape2D: any, alignCorners: any): any;
    resizeNearestNeighbor(newShape2D: any, alignCorners: any): any;
    reverse(axis: any): any;
    rfft(): any;
    round(): any;
    rsqrt(): any;
    selu(): any;
    separableConv2d(depthwiseFilter: any, pointwiseFilter: any, strides: any, pad: any, dilation: any, dataFormat: any): any;
    sigmoid(): any;
    sign(): any;
    sin(): any;
    sinh(): any;
    slice(begin: any, size: any): any;
    softmax(dim: any): any;
    softplus(): any;
    spaceToBatchND(blockShape: any, paddings: any): any;
    split(numOrSizeSplits: any, axis: any): any;
    sqrt(): any;
    square(): any;
    squaredDifference(x: any): any;
    squaredDifferenceStrict(x: any): any;
    squeeze(axis: any): any;
    stack(x: any, axis: any): any;
    step(alpha: any): any;
    stridedSlice(begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
    sub(x: any): any;
    subStrict(x: any): any;
    sum(axis: any, keepDims: any): any;
    tan(): any;
    tanh(): any;
    throwIfDisposed(): void;
    tile(reps: any): any;
    toBool(): any;
    toFloat(): any;
    toInt(): any;
    toString(verbose: any): any;
    topk(k: any, sorted: any): any;
    transpose(perm: any): any;
    unsortedSegmentSum(segmentIds: any, numSegments: any): any;
    unstack(axis: any): any;
    variable(trainable: any, name: any, dtype: any): any;
    where(condition: any, x: any): any;
    zerosLike(): any;
}
export function abs(...args: any[]): any;
export function acos(...args: any[]): any;
export function acosh(...args: any[]): any;
export function add(...args: any[]): any;
export function addN(...args: any[]): any;
export function addStrict(...args: any[]): any;
export function all(...args: any[]): any;
export function any(...args: any[]): any;
export function argMax(...args: any[]): any;
export function argMin(...args: any[]): any;
export function asin(...args: any[]): any;
export function asinh(...args: any[]): any;
export function atan(...args: any[]): any;
export function atan2(...args: any[]): any;
export function atanh(...args: any[]): any;
export function avgPool(...args: any[]): any;
export function basicLSTMCell(...args: any[]): any;
export function batchNorm(...args: any[]): any;
export function batchNorm2d(...args: any[]): any;
export function batchNorm3d(...args: any[]): any;
export function batchNorm4d(...args: any[]): any;
export function batchNormalization(...args: any[]): any;
export function batchNormalization2d(...args: any[]): any;
export function batchNormalization3d(...args: any[]): any;
export function batchNormalization4d(...args: any[]): any;
export function batchToSpaceND(...args: any[]): any;
export namespace browser {
    function fromPixels(...args: any[]): any;
    function toPixels(img: any, canvas: any): any;
}
export function buffer(shape: any, dtype: any, values: any): any;
export function cast(...args: any[]): any;
export function ceil(...args: any[]): any;
export function clipByValue(...args: any[]): any;
export function clone(...args: any[]): any;
export function complex(...args: any[]): any;
export function concat(...args: any[]): any;
export function concat1d(...args: any[]): any;
export function concat2d(...args: any[]): any;
export function concat3d(...args: any[]): any;
export function concat4d(...args: any[]): any;
export namespace constraints {
    function maxNorm(args: any): any;
    function minMaxNorm(config: any): any;
    function nonNeg(): any;
    function unitNorm(args: any): any;
}
export function conv1d(...args: any[]): any;
export function conv2d(...args: any[]): any;
export function conv2dDerFilter(...args: any[]): any;
export function conv2dTranspose(...args: any[]): any;
export function conv3d(...args: any[]): any;
export function cos(...args: any[]): any;
export function cosh(...args: any[]): any;
export function cumsum(...args: any[]): any;
export function customGrad(f: any): any;
export namespace data {
    class CSVDataset {
        constructor(input: any, csvConfig: any);
        batch(batchSize: any, smallLastBatch: any): any;
        columnNames(): any;
        concatenate(dataset: any): any;
        filter(predicate: any): any;
        forEach(f: any): any;
        forEachAsync(f: any): any;
        getBoolean(value: any): any;
        iterator(): any;
        makeDataElement(line: any): any;
        map(transform: any): any;
        mapAsync(transform: any): any;
        maybeReadHeaderLine(): any;
        parseRow(line: any): any;
        prefetch(bufferSize: any): any;
        repeat(count: any): any;
        setColumnNames(): any;
        shuffle(bufferSize: any, seed: any, reshuffleEachIteration: any): any;
        skip(count: any): any;
        take(count: any): any;
        toArray(): any;
    }
    class Dataset {
        size: any;
        batch(batchSize: any, smallLastBatch: any): any;
        concatenate(dataset: any): any;
        filter(predicate: any): any;
        forEach(f: any): any;
        forEachAsync(f: any): any;
        map(transform: any): any;
        mapAsync(transform: any): any;
        prefetch(bufferSize: any): any;
        repeat(count: any): any;
        shuffle(bufferSize: any, seed: any, reshuffleEachIteration: any): any;
        skip(count: any): any;
        take(count: any): any;
        toArray(): any;
    }
    class FileDataSource {
        constructor(input: any, options: any);
        iterator(): any;
    }
    class TextLineDataset {
        constructor(input: any);
        batch(batchSize: any, smallLastBatch: any): any;
        concatenate(dataset: any): any;
        filter(predicate: any): any;
        forEach(f: any): any;
        forEachAsync(f: any): any;
        iterator(): any;
        map(transform: any): any;
        mapAsync(transform: any): any;
        prefetch(bufferSize: any): any;
        repeat(count: any): any;
        shuffle(bufferSize: any, seed: any, reshuffleEachIteration: any): any;
        skip(count: any): any;
        take(count: any): any;
        toArray(): any;
    }
    class URLDataSource {
        constructor(url: any, fileOptions: any);
        iterator(): any;
    }
    function array(items: any): any;
    function csv(source: any, csvConfig: any): any;
    function generator(f: any): any;
    const version_data: string;
    function zip(datasets: any): any;
}
export function deprecationWarn(msg: any): void;
export function depthToSpace(...args: any[]): any;
export function depthwiseConv2d(...args: any[]): any;
export function disableDeprecationWarnings(): void;
export function dispose(container: any): void;
export function disposeVariables(): void;
export function div(...args: any[]): any;
export function divStrict(...args: any[]): any;
export function dot(...args: any[]): any;
export function elu(...args: any[]): any;
export function enableProdMode(): void;
export namespace environment {
    const ENV: {
        backend: any;
        engine: any;
        evaluateFeature: Function;
        features: {
            DEBUG: boolean;
            IS_BROWSER: boolean;
        };
        findBackend: Function;
        get: Function;
        getBestBackendName: Function;
        getFeatures: Function;
        initEngine: Function;
        registerBackend: Function;
        registry: {
            cpu: {
                backend: any;
                priority: any;
            };
        };
        removeBackend: Function;
        reset: Function;
        set: Function;
        setFeatures: Function;
    };
    const EPSILON_FLOAT16: number;
    const EPSILON_FLOAT32: number;
    class Environment {
        static dispose(container: any): void;
        static disposeVariables(): void;
        static getBackend(): any;
        static keep(result: any): any;
        static memory(): any;
        static profile(f: any): any;
        static setBackend(backendName: any, safeMode: any): void;
        static tidy(nameOrFn: any, fn: any): any;
        static time(f: any): any;
        constructor(features: any);
        features: any;
        registry: any;
        evaluateFeature(feature: any): any;
        findBackend(name: any): any;
        get(feature: any): any;
        getBestBackendName(): any;
        getFeatures(): any;
        initEngine(): void;
        registerBackend(name: any, factory: any, priority: any, setTensorTrackerFn: any): any;
        removeBackend(name: any): void;
        reset(): void;
        set(feature: any, value: any): void;
        setFeatures(features: any): void;
    }
    function deprecationWarn(msg: any): void;
    function disableDeprecationWarnings(): void;
    function enableProdMode(): void;
}
export function equal(...args: any[]): any;
export function equalStrict(...args: any[]): any;
export function erf(...args: any[]): any;
export function exp(...args: any[]): any;
export function expandDims(...args: any[]): any;
export function expm1(...args: any[]): any;
export function eye(...args: any[]): any;
export function fft(...args: any[]): any;
export function fill(shape: any, value: any, dtype: any): any;
export function floor(...args: any[]): any;
export function floorDiv(...args: any[]): any;
export function fromPixels(pixels: any, numChannels: any): any;
export namespace fused {
    function matMul(...args: any[]): any;
}
export function gather(...args: any[]): any;
export function gatherND(...args: any[]): any;
export function getBackend(): any;
export function grad(f: any): any;
export function grads(f: any): any;
export function greater(...args: any[]): any;
export function greaterEqual(...args: any[]): any;
export function greaterEqualStrict(...args: any[]): any;
export function greaterStrict(...args: any[]): any;
export function ifft(...args: any[]): any;
export function imag(...args: any[]): any;
export namespace image {
    function cropAndResize(...args: any[]): any;
    function nonMaxSuppression(...args: any[]): any;
    function nonMaxSuppressionAsync(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): any;
    function resizeBilinear(...args: any[]): any;
    function resizeNearestNeighbor(...args: any[]): any;
}
export namespace initializers {
    function constant(args: any): any;
    function glorotNormal(args: any): any;
    function glorotUniform(args: any): any;
    function heNormal(args: any): any;
    function heUniform(args: any): any;
    function identity(args: any): any;
    function leCunNormal(args: any): any;
    function leCunUniform(args: any): any;
    function ones(): any;
    function orthogonal(args: any): any;
    function randomNormal(args: any): any;
    function randomUniform(args: any): any;
    function truncatedNormal(args: any): any;
    function varianceScaling(config: any): any;
    function zeros(): any;
}
export function input(config: any): any;
export namespace io {
    function browserFiles(files: any): any;
    function browserHTTPRequest(path: any, requestInit: any, weightPathPrefix: any, fetchFunc: any, onProgress: any): any;
    function concatenateArrayBuffers(buffers: any): any;
    function copyModel(sourceURL: any, destURL: any): any;
    function decodeWeights(buffer: any, specs: any): any;
    function encodeWeights(tensors: any): any;
    function fromMemory(modelTopology: any, weightSpecs: any, weightData: any): any;
    function getLoadHandlers(url: any, onProgress: any): any;
    function getModelArtifactsInfoForJSON(modelArtifacts: any): any;
    function getSaveHandlers(url: any): any;
    function isHTTPScheme(url: any): any;
    function listModels(): any;
    function loadWeights(manifest: any, filePathPrefix: any, weightNames: any, requestOptions: any): any;
    function moveModel(sourceURL: any, destURL: any): any;
    function registerLoadRouter(loudRouter: any): any;
    function registerSaveRouter(loudRouter: any): any;
    function removeModel(url: any): any;
    function weightsLoaderFactory(fetchWeightsFunction: any): any;
    function withSaveHandler(saveHandler: any): any;
}
export function irfft(...args: any[]): any;
export function keep(result: any): any;
export namespace layers {
    class Layer {
        static fromConfig(cls: any, config: any): any;
        static nodeKey(layer: any, nodeIndex: any): any;
        constructor(args: any);
        addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
        addLoss(losses: any): void;
        addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
        apply(inputs: any, kwargs: any): any;
        assertInputCompatibility(inputs: any): void;
        assertNotDisposed(): void;
        build(inputShape: any): void;
        calculateLosses(): any;
        call(inputs: any, kwargs: any): any;
        clearCallHook(): void;
        computeMask(inputs: any, mask: any): any;
        computeOutputShape(inputShape: any): any;
        countParams(): any;
        dispose(): any;
        disposeWeights(): any;
        getClassName(): any;
        getConfig(): any;
        getInputAt(nodeIndex: any): any;
        getNodeAtIndex(nodeIndex: any, attrName: any): any;
        getOutputAt(nodeIndex: any): any;
        getWeights(trainableOnly: any): any;
        invokeCallHook(inputs: any, kwargs: any): void;
        resetStates(): void;
        setCallHook(callHook: any): void;
        setFastWeightInitDuringBuild(value: any): void;
        setWeights(weights: any): void;
        warnOnIncompatibleInputShape(inputShape: any): void;
    }
    class RNN {
        static className: string;
        static fromConfig(cls: any, config: any): any;
        static nodeKey(layer: any, nodeIndex: any): any;
        constructor(args: any);
        addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
        addLoss(losses: any): void;
        addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
        apply(inputs: any, kwargs: any): any;
        assertInputCompatibility(inputs: any): void;
        assertNotDisposed(): void;
        build(inputShape: any): void;
        calculateLosses(): any;
        call(inputs: any, kwargs: any): any;
        clearCallHook(): void;
        computeMask(inputs: any, mask: any): any;
        computeOutputShape(inputShape: any): any;
        countParams(): any;
        dispose(): any;
        disposeWeights(): any;
        getClassName(): any;
        getConfig(): any;
        getInitialState(inputs: any): any;
        getInputAt(nodeIndex: any): any;
        getNodeAtIndex(nodeIndex: any, attrName: any): any;
        getOutputAt(nodeIndex: any): any;
        getStates(): any;
        getWeights(trainableOnly: any): any;
        invokeCallHook(inputs: any, kwargs: any): void;
        resetStates(states: any, training: any): void;
        setCallHook(callHook: any): void;
        setFastWeightInitDuringBuild(value: any): void;
        setStates(states: any): void;
        setWeights(weights: any): void;
        warnOnIncompatibleInputShape(inputShape: any): void;
    }
    class RNNCell {
        static fromConfig(cls: any, config: any): any;
        static nodeKey(layer: any, nodeIndex: any): any;
        constructor(...args: any[]);
        addInboundNode(inputTensors: any, outputTensors: any, inputMasks: any, outputMasks: any, inputShapes: any, outputShapes: any, kwargs: any): void;
        addLoss(losses: any): void;
        addWeight(name: any, shape: any, dtype: any, initializer: any, regularizer: any, trainable: any, constraint: any): any;
        apply(inputs: any, kwargs: any): any;
        assertInputCompatibility(inputs: any): void;
        assertNotDisposed(): void;
        build(inputShape: any): void;
        calculateLosses(): any;
        call(inputs: any, kwargs: any): any;
        clearCallHook(): void;
        computeMask(inputs: any, mask: any): any;
        computeOutputShape(inputShape: any): any;
        countParams(): any;
        dispose(): any;
        disposeWeights(): any;
        getClassName(): any;
        getConfig(): any;
        getInputAt(nodeIndex: any): any;
        getNodeAtIndex(nodeIndex: any, attrName: any): any;
        getOutputAt(nodeIndex: any): any;
        getWeights(trainableOnly: any): any;
        invokeCallHook(inputs: any, kwargs: any): void;
        resetStates(): void;
        setCallHook(callHook: any): void;
        setFastWeightInitDuringBuild(value: any): void;
        setWeights(weights: any): void;
        warnOnIncompatibleInputShape(inputShape: any): void;
    }
    function activation(args: any): any;
    function add(args: any): any;
    function average(args: any): any;
    function averagePooling1d(args: any): any;
    function averagePooling2d(args: any): any;
    function avgPool1d(args: any): any;
    function avgPool2d(args: any): any;
    function avgPooling1d(args: any): any;
    function avgPooling2d(args: any): any;
    function batchNormalization(args: any): any;
    function bidirectional(args: any): any;
    function concatenate(args: any): any;
    function conv1d(args: any): any;
    function conv2d(args: any): any;
    function conv2dTranspose(args: any): any;
    function cropping2D(args: any): any;
    function dense(args: any): any;
    function depthwiseConv2d(args: any): any;
    function dot(args: any): any;
    function dropout(args: any): any;
    function elu(args: any): any;
    function embedding(args: any): any;
    function flatten(args: any): any;
    function globalAveragePooling1d(args: any): any;
    function globalAveragePooling2d(args: any): any;
    function globalMaxPool1d(args: any): any;
    function globalMaxPool2d(args: any): any;
    function globalMaxPooling1d(args: any): any;
    function globalMaxPooling2d(args: any): any;
    function gru(args: any): any;
    function gruCell(args: any): any;
    function input(config: any): any;
    function inputLayer(args: any): any;
    function leakyReLU(args: any): any;
    function lstm(args: any): any;
    function lstmCell(args: any): any;
    function maxPool1d(args: any): any;
    function maxPool2d(args: any): any;
    function maxPooling1d(args: any): any;
    function maxPooling2d(args: any): any;
    function maximum(args: any): any;
    function minimum(args: any): any;
    function multiply(args: any): any;
    function permute(args: any): any;
    function prelu(args: any): any;
    function reLU(args: any): any;
    function repeatVector(args: any): any;
    function reshape(args: any): any;
    function rnn(args: any): any;
    function separableConv2d(args: any): any;
    function simpleRNN(args: any): any;
    function simpleRNNCell(args: any): any;
    function softmax(args: any): any;
    function stackedRNNCells(args: any): any;
    function thresholdedReLU(args: any): any;
    function timeDistributed(args: any): any;
    function upSampling2d(args: any): any;
    function zeroPadding2d(args: any): any;
}
export function leakyRelu(...args: any[]): any;
export function less(...args: any[]): any;
export function lessEqual(...args: any[]): any;
export function lessEqualStrict(...args: any[]): any;
export function lessStrict(...args: any[]): any;
export namespace linalg {
    function gramSchmidt(...args: any[]): any;
    function qr(...args: any[]): any;
}
export function linspace(start: any, stop: any, num: any): any;
export function loadFrozenModel(modelUrl: any, weightsManifestUrl: any, requestOption: any, onProgress: any): any;
export function loadGraphModel(modelUrl: any, options: any): any;
export function loadLayersModel(pathOrIOHandler: any, options: any): any;
export function loadModel(pathOrIOHandler: any, strict: any): any;
export function loadTfHubModule(tfhubModuleUrl: any, requestOption: any, onProgress: any): any;
export function localResponseNormalization(...args: any[]): any;
export function log(...args: any[]): any;
export function log1p(...args: any[]): any;
export function logSigmoid(...args: any[]): any;
export function logSoftmax(...args: any[]): any;
export function logSumExp(...args: any[]): any;
export function logicalAnd(...args: any[]): any;
export function logicalNot(...args: any[]): any;
export function logicalOr(...args: any[]): any;
export function logicalXor(...args: any[]): any;
export namespace losses {
    const Reduction: {
        "0": string;
        "1": string;
        "2": string;
        "3": string;
        MEAN: number;
        NONE: number;
        SUM: number;
        SUM_BY_NONZERO_WEIGHTS: number;
    };
    function absoluteDifference(...args: any[]): any;
    function computeWeightedLoss(...args: any[]): any;
    function cosineDistance(...args: any[]): any;
    function hingeLoss(...args: any[]): any;
    function huberLoss(...args: any[]): any;
    function logLoss(...args: any[]): any;
    function meanSquaredError(...args: any[]): any;
    function sigmoidCrossEntropy(...args: any[]): any;
    function softmaxCrossEntropy(...args: any[]): any;
}
export function matMul(...args: any[]): any;
export namespace math {
    function confusionMatrix(...args: any[]): any;
}
export function max(...args: any[]): any;
export function maxPool(...args: any[]): any;
export function maximum(...args: any[]): any;
export function maximumStrict(...args: any[]): any;
export function mean(...args: any[]): any;
export function memory(): any;
export namespace metrics {
    function MAPE(yTrue: any, yPred: any): any;
    function MSE(yTrue: any, yPred: any): any;
    function binaryAccuracy(yTrue: any, yPred: any): any;
    function binaryCrossentropy(yTrue: any, yPred: any): any;
    function categoricalAccuracy(yTrue: any, yPred: any): any;
    function categoricalCrossentropy(yTrue: any, yPred: any): any;
    function cosineProximity(yTrue: any, yPred: any): any;
    function mape(yTrue: any, yPred: any): any;
    function meanAbsoluteError(yTrue: any, yPred: any): any;
    function meanAbsolutePercentageError(yTrue: any, yPred: any): any;
    function meanSquaredError(yTrue: any, yPred: any): any;
    function mse(yTrue: any, yPred: any): any;
    function precision(yTrue: any, yPred: any): any;
    function recall(yTrue: any, yPred: any): any;
    function sparseCategoricalAccuracy(yTrue: any, yPred: any): any;
}
export function min(...args: any[]): any;
export function minimum(...args: any[]): any;
export function minimumStrict(...args: any[]): any;
export function mod(...args: any[]): any;
export function modStrict(...args: any[]): any;
export function model(args: any): any;
export namespace models {
    function modelFromJSON(modelAndWeightsConfig: any, customObjects: any): any;
}
export function moments(...args: any[]): any;
export function movingAverage(...args: any[]): any;
export function mul(...args: any[]): any;
export function mulStrict(...args: any[]): any;
export function multiRNNCell(...args: any[]): any;
export function multinomial(...args: any[]): any;
export function neg(...args: any[]): any;
export function nextFrame(): any;
export function norm(...args: any[]): any;
export function notEqual(...args: any[]): any;
export function notEqualStrict(...args: any[]): any;
export function oneHot(...args: any[]): any;
export function ones(shape: any, dtype: any): any;
export function onesLike(...args: any[]): any;
export function op(f: any): any;
export function outerProduct(...args: any[]): any;
export function pad(...args: any[]): any;
export function pad1d(...args: any[]): any;
export function pad2d(...args: any[]): any;
export function pad3d(...args: any[]): any;
export function pad4d(...args: any[]): any;
export function pool(...args: any[]): any;
export function pow(...args: any[]): any;
export function powStrict(...args: any[]): any;
export function prelu(...args: any[]): any;
export function print(x: any, verbose: any): void;
export function prod(...args: any[]): any;
export function profile(f: any): any;
export function rand(...args: any[]): any;
export function randomNormal(...args: any[]): any;
export function randomUniform(...args: any[]): any;
export function range(start: any, stop: any, step: any, dtype: any): any;
export function real(...args: any[]): any;
export function reciprocal(...args: any[]): any;
export function registerCallbackConstructor(verbosityLevel: any, callbackConstructor: any): void;
export namespace regularizers {
    function l1(config: any): any;
    function l1l2(config: any): any;
    function l2(config: any): any;
}
export function relu(...args: any[]): any;
export function reshape(...args: any[]): any;
export function reverse(...args: any[]): any;
export function reverse1d(...args: any[]): any;
export function reverse2d(...args: any[]): any;
export function reverse3d(...args: any[]): any;
export function reverse4d(...args: any[]): any;
export function rfft(...args: any[]): any;
export function round(...args: any[]): any;
export function rsqrt(...args: any[]): any;
export function scalar(value: any, dtype: any): any;
export function scatterND(...args: any[]): any;
export function selu(...args: any[]): any;
export function separableConv2d(...args: any[]): any;
export function sequential(config: any): any;
export namespace serialization {
    class Serializable {
        static fromConfig(cls: any, config: any): any;
        getClassName(): any;
    }
    class SerializationMap {
        static getMap(): any;
        static instance: {
            classNameMap: {
                Activation: any;
                AdadeltaOptimizer: any;
                AdagradOptimizer: any;
                AdamOptimizer: any;
                AdamaxOptimizer: any;
                Add: any;
                Average: any;
                AveragePooling1D: any;
                AveragePooling2D: any;
                BatchNormalization: any;
                Bidirectional: any;
                Concatenate: any;
                Constant: any;
                Conv1D: any;
                Conv2D: any;
                Conv2DTranspose: any;
                Cropping2D: any;
                Dense: any;
                DepthwiseConv2D: any;
                Dot: any;
                Dropout: any;
                ELU: any;
                Embedding: any;
                Flatten: any;
                GRU: any;
                GRUCell: any;
                GlobalAveragePooling1D: any;
                GlobalAveragePooling2D: any;
                GlobalMaxPooling1D: any;
                GlobalMaxPooling2D: any;
                GlorotNormal: any;
                GlorotUniform: any;
                HeNormal: any;
                HeUniform: any;
                Identity: any;
                InputLayer: any;
                L1L2: any;
                LSTM: any;
                LSTMCell: any;
                LeCunNormal: any;
                LeakyReLU: any;
                MaxNorm: any;
                MaxPooling1D: any;
                MaxPooling2D: any;
                Maximum: any;
                MinMaxNorm: any;
                Minimum: any;
                Model: any;
                MomentumOptimizer: any;
                Multiply: any;
                NonNeg: any;
                Ones: any;
                Orthogonal: any;
                PReLU: any;
                Permute: any;
                RMSPropOptimizer: any;
                RNN: any;
                RandomNormal: any;
                RandomUniform: any;
                ReLU: any;
                RepeatVector: any;
                Reshape: any;
                SGDOptimizer: any;
                SeparableConv2D: any;
                Sequential: any;
                SimpleRNN: any;
                SimpleRNNCell: any;
                Softmax: any;
                StackedRNNCells: any;
                ThresholdedReLU: any;
                TimeDistributed: any;
                TruncatedNormal: any;
                UnitNorm: any;
                UpSampling2D: any;
                VarianceScaling: any;
                ZeroPadding2D: any;
                Zeros: any;
                elu: any;
                hardSigmoid: any;
                linear: any;
                relu: any;
                relu6: any;
                selu: any;
                sigmoid: any;
                softmax: any;
                softplus: any;
                softsign: any;
                tanh: any;
            };
        };
        static register(cls: any): void;
        classNameMap: any;
    }
    function registerClass(cls: any): void;
}
export function setBackend(backendName: any, safeMode: any): void;
export function setdiff1dAsync(x: any, y: any): any;
export function sigmoid(...args: any[]): any;
export function sign(...args: any[]): any;
export function sin(...args: any[]): any;
export function sinh(...args: any[]): any;
export function slice(...args: any[]): any;
export function slice1d(...args: any[]): any;
export function slice2d(...args: any[]): any;
export function slice3d(...args: any[]): any;
export function slice4d(...args: any[]): any;
export function softmax(...args: any[]): any;
export function softplus(...args: any[]): any;
export function spaceToBatchND(...args: any[]): any;
export function sparseToDense(...args: any[]): any;
export namespace spectral {
    function fft(...args: any[]): any;
    function ifft(...args: any[]): any;
    function irfft(...args: any[]): any;
    function rfft(...args: any[]): any;
}
export function split(...args: any[]): any;
export function sqrt(...args: any[]): any;
export function square(...args: any[]): any;
export function squaredDifference(...args: any[]): any;
export function squaredDifferenceStrict(...args: any[]): any;
export function squeeze(...args: any[]): any;
export function stack(...args: any[]): any;
export function step(...args: any[]): any;
export function stridedSlice(...args: any[]): any;
export function sub(...args: any[]): any;
export function subStrict(...args: any[]): any;
export function sum(...args: any[]): any;
export function tan(...args: any[]): any;
export function tanh(...args: any[]): any;
export function tensor(values: any, shape: any, dtype: any): any;
export function tensor1d(values: any, dtype: any): any;
export function tensor2d(values: any, shape: any, dtype: any): any;
export function tensor3d(values: any, shape: any, dtype: any): any;
export function tensor4d(values: any, shape: any, dtype: any): any;
export function tensor5d(values: any, shape: any, dtype: any): any;
export function tensor6d(values: any, shape: any, dtype: any): any;
export namespace test_util {
    const ALL_ENVS: {};
    const BROWSER_ENVS: {
        IS_BROWSER: boolean;
    };
    const CHROME_ENVS: {
        IS_CHROME: boolean;
    };
    const CPU_ENVS: {
        HAS_WEBGL: boolean;
    };
    const NODE_ENVS: {
        IS_NODE: boolean;
    };
    const PACKED_ENVS: {
        WEBGL_PACK: boolean;
    };
    const WEBGL_ENVS: {
        HAS_WEBGL: boolean;
    };
    function expectArrayBuffersEqual(actual: any, expected: any): void;
    function expectArraysClose(actual: any, expected: any, epsilon: any): any;
    function expectArraysEqual(actual: any, expected: any): any;
    function expectNumbersClose(a: any, e: any, epsilon: any): void;
    function expectPromiseToFail(fn: any, done: any): void;
    function expectValuesInRange(actual: any, low: any, high: any): void;
}
export function tidy(nameOrFn: any, fn: any): any;
export function tile(...args: any[]): any;
export function time(f: any): any;
export function toPixels(img: any, canvas: any): any;
export function topk(...args: any[]): any;
export namespace train {
    function adadelta(learningRate: any, rho: any, epsilon: any): any;
    function adagrad(learningRate: any, initialAccumulatorValue: any): any;
    function adam(learningRate: any, beta1: any, beta2: any, epsilon: any): any;
    function adamax(learningRate: any, beta1: any, beta2: any, epsilon: any, decay: any): any;
    function momentum(learningRate: any, momentum: any, useNesterov: any): any;
    function rmsprop(learningRate: any, decay: any, momentum: any, epsilon: any, centered: any): any;
    function sgd(learningRate: any): any;
}
export function transpose(...args: any[]): any;
export function truncatedNormal(...args: any[]): any;
export function unsortedSegmentSum(...args: any[]): any;
export function unstack(...args: any[]): any;
export namespace util {
    function arraysEqual(n1: any, n2: any): any;
    function assert(expr: any, msg: any): void;
    function assertNonNull(a: any): void;
    function assertShapesMatch(shapeA: any, shapeB: any, errorMessagePrefix: any): void;
    function bytesFromStringArray(arr: any): any;
    function bytesPerElement(dtype: any): any;
    function checkComputationForErrors(vals: any, dtype: any, name: any): void;
    function checkConversionForErrors(vals: any, dtype: any): void;
    function clamp(min: any, x: any, max: any): any;
    function computeStrides(shape: any): any;
    function createShuffledIndices(n: any): any;
    function distSquared(a: any, b: any): any;
    function flatten(arr: any, ret: any): any;
    function getArrayFromDType(dtype: any, size: any): any;
    function getTypedArrayFromDType(dtype: any, size: any): any;
    function hasEncodingLoss(oldType: any, newType: any): any;
    function inferDtype(values: any): any;
    function inferFromImplicitShape(shape: any, size: any): any;
    function isBoolean(value: any): any;
    function isFunction(f: any): any;
    function isInt(a: any): any;
    function isNumber(value: any): any;
    function isScalarShape(shape: any): any;
    function isString(value: any): any;
    function isTypedArray(a: any): any;
    function makeOnesTypedArray(size: any, dtype: any): any;
    function makeZerosTypedArray(size: any, dtype: any): any;
    function monitorPromisesProgress(promises: any, onProgress: any, startFraction: any, endFraction: any): any;
    function nearestDivisor(size: any, start: any): any;
    function nearestLargerEven(val: any): any;
    function now(): any;
    function parseAxisParam(axis: any, shape: any): any;
    function randUniform(a: any, b: any): any;
    function repeatedTry(checkFn: any, delayFn: any, maxCounter: any): any;
    function rightPad(a: any, size: any): any;
    function shuffle(array: any): void;
    function sizeFromShape(shape: any): any;
    function sizeToSquarishShape(size: any): any;
    function squeezeShape(shape: any, axis: any): any;
    function sum(arr: any): any;
    function tanh(x: any): any;
    function toNestedArray(shape: any, a: any): any;
    function toTypedArray(a: any, dtype: any, debugMode: any): any;
}
export function valueAndGrad(f: any): any;
export function valueAndGrads(f: any): any;
export function variable(initialValue: any, trainable: any, name: any, dtype: any): any;
export function variableGrads(f: any, varList: any): any;
export const version: {
    tfjs: string;
    "tfjs-converter": string;
    "tfjs-core": string;
    "tfjs-data": string;
    "tfjs-layers": string;
};
export const version_converter: string;
export const version_core: string;
export const version_layers: string;
export namespace webgl {
    class GPGPUContext {
        constructor(gl: any);
        outputTexture: any;
        program: any;
        disposed: any;
        autoDebugValidate: any;
        vertexAttrsAreBound: any;
        itemsToPoll: any;
        gl: any;
        textureFloatExtension: any;
        colorBufferFloatExtension: any;
        textureHalfFloatExtension: any;
        colorBufferHalfFloatExtension: any;
        vertexBuffer: any;
        indexBuffer: any;
        framebuffer: any;
        textureConfig: any;
        addItemToPoll(isDoneFn: any, resolveFn: any): void;
        beginQuery(): any;
        bindTextureToFrameBuffer(texture: any): void;
        blockUntilAllProgramsCompleted(): void;
        createAndWaitForFence(): any;
        createFence(gl: any): any;
        createFloat16MatrixTexture(rows: any, columns: any): any;
        createFloat16PackedMatrixTexture(rows: any, columns: any): any;
        createFloat32MatrixTexture(rows: any, columns: any): any;
        createPackedMatrixTexture(rows: any, columns: any): any;
        createProgram(fragmentShaderSource: any): any;
        createUnsignedBytesMatrixTexture(rows: any, columns: any): any;
        debugValidate(): void;
        deleteMatrixTexture(texture: any): void;
        deleteProgram(program: any): void;
        dispose(): void;
        downloadByteEncodedFloatMatrixFromOutputTexture(texture: any, rows: any, columns: any): any;
        downloadFloat32MatrixFromBuffer(buffer: any, rows: any, columns: any): any;
        downloadFloat32MatrixFromOutputTexture(texture: any, rows: any, columns: any): any;
        downloadMatrixDriver(texture: any, downloadAndDecode: any): any;
        downloadMatrixFromPackedTexture(texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any): any;
        downloadPackedMatrixFromBuffer(buffer: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any): any;
        enableAutomaticDebugValidation(enabled: any): void;
        endQuery(): void;
        executeProgram(): void;
        getAttributeLocation(program: any, attribute: any): any;
        getQueryTime(query: any, queryTimerVersion: any): any;
        getQueryTimerExtension(): any;
        getQueryTimerExtensionWebGL1(): any;
        getQueryTimerExtensionWebGL2(): any;
        getUniformLocation(program: any, uniformName: any, shouldThrow: any): any;
        getUniformLocationNoThrow(program: any, uniformName: any): any;
        isQueryAvailable(query: any, queryTimerVersion: any): any;
        maybeCreateBufferFromTexture(texture: any, rows: any, columns: any): any;
        pollFence(fenceContext: any): any;
        pollItems(): void;
        setInputMatrixTexture(inputMatrixTexture: any, uniformLocation: any, textureUnit: any): void;
        setOutputMatrixTexture(outputMatrixTexture: any, rows: any, columns: any): void;
        setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked: any, width: any, height: any): void;
        setOutputMatrixWriteRegion(startRow: any, numRows: any, startColumn: any, numColumns: any): void;
        setOutputMatrixWriteRegionDriver(x: any, y: any, width: any, height: any): void;
        setOutputPackedMatrixTexture(outputPackedMatrixTexture: any, rows: any, columns: any): void;
        setOutputPackedMatrixWriteRegion(startRow: any, numRows: any, startColumn: any, numColumns: any): void;
        setProgram(program: any): void;
        throwIfDisposed(): void;
        throwIfNoProgram(): void;
        unbindTextureToFrameBuffer(): void;
        uploadMatrixToPackedTexture(texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any, matrix: any): any;
        uploadMatrixToTexture(texture: any, rows: any, columns: any, matrix: any): any;
        uploadPixelDataToTexture(texture: any, pixels: any): void;
        waitForQueryAndGetTime(query: any): any;
    }
    class MathBackendWebGL {
        constructor(gpgpu: any, delayedStorage: any);
        gpgpu: any;
        delayedStorage: any;
        pendingRead: any;
        pendingDisposal: any;
        dataRefCount: any;
        lruDataGPU: any;
        numBytesInGPU: any;
        uploadWaitMs: any;
        downloadWaitMs: any;
        binaryCache: any;
        disposed: any;
        canvas: any;
        gpgpuCreatedLocally: any;
        textureManager: any;
        LRNGrad(dy: any, inputImage: any, outputImage: any, depthRadius: any, bias: any, alpha: any, beta: any): any;
        abs(x: any): any;
        acos(x: any): any;
        acosh(x: any): any;
        acquireTexture(dataId: any, texShape: any, texType: any, isPacked: any): any;
        add(a: any, b: any): any;
        addN(tensors: any): any;
        all(x: any, axes: any): any;
        any(x: any, axes: any): any;
        argMax(x: any, axis: any): any;
        argMin(x: any, axis: any): any;
        argReduce(x: any, reduceType: any, bestIndicesA: any): any;
        asin(x: any): any;
        asinh(x: any): any;
        atan(x: any): any;
        atan2(a: any, b: any): any;
        atanh(x: any): any;
        avgPool(x: any, convInfo: any): any;
        avgPoolBackprop(dy: any, x: any, convInfo: any): any;
        batchMatMul(a: any, b: any, transposeA: any, transposeB: any): any;
        batchNormalization(x: any, mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
        batchToSpaceND(x: any, blockShape: any, crops: any): any;
        cast(x: any, dtype: any): any;
        ceil(x: any): any;
        clip(x: any, min: any, max: any): any;
        compileAndRun(program: any, inputs: any, output: any, customSetup: any, pageToCpu: any): any;
        complex(real: any, imag: any): any;
        complexAbs(x: any): any;
        complexSeparableBinaryOp(a: any, b: any, op: any): any;
        computeBytes(shape: any, dtype: any): any;
        concat(tensors: any, axis: any): any;
        conv2d(x: any, filter: any, convInfo: any): any;
        conv2dDerFilter(x: any, dy: any, convInfo: any): any;
        conv2dDerInput(dy: any, filter: any, convInfo: any): any;
        conv2dWithIm2Row(x: any, filter: any, convInfo: any): any;
        conv3d(x: any, filter: any, convInfo: any): any;
        conv3dDerFilter(x: any, dy: any, convInfo: any): any;
        conv3dDerInput(dy: any, filter: any, convInfo: any): any;
        convertAndCacheOnCPU(dataId: any, float32Values: any): any;
        cos(x: any): any;
        cosh(x: any): any;
        cropAndResize(image: any, boxes: any, boxIndex: any, cropSize: any, method: any, extrapolationValue: any): any;
        cumsum(x: any, axis: any, exclusive: any, reverse: any): any;
        depthToSpace(x: any, blockSize: any, dataFormat: any): any;
        depthwiseConv2D(x: any, filter: any, convInfo: any): any;
        depthwiseConv2DDerFilter(x: any, dy: any, convInfo: any): any;
        depthwiseConv2DDerInput(dy: any, filter: any, convInfo: any): any;
        dispose(): void;
        disposeData(dataId: any): void;
        elu(x: any): any;
        eluDer(dy: any, y: any): any;
        endTimer(query: any): any;
        equal(a: any, b: any): any;
        erf(x: any): any;
        exp(x: any): any;
        expm1(x: any): any;
        fft(x: any): any;
        fftImpl(x: any, inverse: any): any;
        floatPrecision(): any;
        floor(x: any): any;
        floorDiv(a: any, b: any): any;
        fromPixels(pixels: any, numChannels: any): any;
        fusedBatchMatMul(a: any, b: any, transposeA: any, transposeB: any, bias: any, activation: any): any;
        gather(x: any, indices: any, axis: any): any;
        gatherND(x: any, indices: any): any;
        getAndSaveBinary(key: any, getBinary: any): any;
        getCPUBackend(): any;
        getCanvas(): any;
        getGPGPUContext(): any;
        getQueryTime(query: any): any;
        getTexture(dataId: any): any;
        getTextureManager(): any;
        getValuesFromTexture(dataId: any): any;
        greater(a: any, b: any): any;
        greaterEqual(a: any, b: any): any;
        ifft(x: any): any;
        imag(input: any): any;
        int(x: any): any;
        less(a: any, b: any): any;
        lessEqual(a: any, b: any): any;
        localResponseNormalization4D(x: any, radius: any, bias: any, alpha: any, beta: any): any;
        log(x: any): any;
        log1p(x: any): any;
        logicalAnd(a: any, b: any): any;
        logicalNot(x: any): any;
        logicalOr(a: any, b: any): any;
        makeComplexComponentTensorHandle(complexTensor: any, complexPart: any): any;
        makeOutputArray(shape: any, dtype: any): any;
        makePackedTensor(shape: any, dtype: any): any;
        makeTensorHandle(shape: any, dtype: any): any;
        max(x: any, axes: any): any;
        maxPool(x: any, convInfo: any): any;
        maxPoolBackprop(dy: any, x: any, y: any, convInfo: any): any;
        maximum(a: any, b: any): any;
        memory(): any;
        min(x: any, axes: any): any;
        minimum(a: any, b: any): any;
        mod(a: any, b: any): any;
        multinomial(logits: any, normalized: any, numSamples: any, seed: any): any;
        multiply(a: any, b: any): any;
        neg(x: any): any;
        nonMaxSuppression(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): any;
        notEqual(a: any, b: any): any;
        oneHot(indices: any, depth: any, onValue: any, offValue: any): any;
        packedBinaryOp(a: any, b: any, op: any, dtype: any): any;
        packedReshape(input: any, afterShape: any): any;
        pad(x: any, paddings: any, constantValue: any): any;
        pow(a: any, b: any): any;
        prelu(x: any, alpha: any): any;
        prod(x: any, axes: any): any;
        read(dataId: any): any;
        readSync(dataId: any): any;
        real(input: any): any;
        realDivide(a: any, b: any): any;
        reciprocal(x: any): any;
        reduce(x: any, reduceType: any, dtype: any): any;
        register(dataId: any, shape: any, dtype: any): void;
        releaseTexture(dataId: any, texture: any, texShape: any, texType: any, isPacked: any): void;
        relu(x: any): any;
        reshape(x: any, shape: any): any;
        resizeBilinear(x: any, newHeight: any, newWidth: any, alignCorners: any): any;
        resizeBilinearBackprop(dy: any, x: any, alignCorners: any): any;
        resizeNearestNeighbor(x: any, newHeight: any, newWidth: any, alignCorners: any): any;
        resizeNearestNeighborBackprop(dy: any, x: any, alignCorners: any): any;
        reverse(x: any, axis: any): any;
        round(x: any): any;
        rsqrt(x: any): any;
        scatterND(indices: any, updates: any, shape: any): any;
        segOpCompute(x: any, segOpType: any, segmentIds: any, dtype: any, numSegments: any): any;
        select(condition: any, a: any, b: any): any;
        selu(x: any): any;
        setDataMover(dataMover: any): void;
        shallowSlice(x: any, begin: any, size: any): any;
        shouldExecuteOnCPU(inputs: any, sizeThreshold: any): any;
        sigmoid(x: any): any;
        sign(x: any): any;
        sin(x: any): any;
        sinh(x: any): any;
        slice(x: any, begin: any, size: any): any;
        softplus(x: any): any;
        spaceToBatchND(x: any, blockShape: any, paddings: any): any;
        sparseToDense(sparseIndices: any, sparseValues: any, outputShape: any, defaultValue: any): any;
        split(x: any, sizeSplits: any, axis: any): any;
        sqrt(x: any): any;
        square(x: any): any;
        squaredDifference(a: any, b: any): any;
        startTimer(): any;
        step(x: any, alpha: any): any;
        stridedSlice(x: any, begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
        subtract(a: any, b: any): any;
        sum(x: any, axes: any): any;
        tan(x: any): any;
        tanh(x: any): any;
        tile(x: any, reps: any): any;
        time(f: any): any;
        topk(x: any, k: any, sorted: any): any;
        transpose(x: any, perm: any): any;
        unpackTensor(input: any): any;
        unsortedSegmentSum(x: any, segmentIds: any, numSegments: any): any;
        unstack(x: any, axis: any): any;
        uploadToGPU(dataId: any): void;
        where(condition: any): any;
        write(dataId: any, values: any): void;
    }
    namespace gpgpu_util {
        function bindVertexProgramAttributeStreams(gl: any, program: any, vertexBuffer: any): any;
        function createFloat16MatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function createFloat16PackedMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function createFloat32MatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function createIndexBuffer(gl: any): any;
        function createPackedMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function createUnsignedBytesMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function createVertexBuffer(gl: any): any;
        function createVertexShader(gl: any): any;
        function downloadByteEncodedFloatMatrixFromOutputTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function downloadFloat32MatrixFromBuffer(gl: any, buffer: any, rows: any, columns: any, textureConfig: any): any;
        function downloadFloat32MatrixFromOutputTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
        function downloadMatrixFromPackedOutputTexture(gl: any, batch: any, rows: any, cols: any, physicalRows: any, physicalCols: any, textureConfig: any): any;
        function downloadPackedMatrixFromBuffer(gl: any, buffer: any, batch: any, rows: any, cols: any, physicalRows: any, physicalCols: any, textureConfig: any): any;
        function getTextureConfig(gl: any, textureHalfFloatExtension: any): any;
        function maybeCreateBufferFromOutputTexture(gl: any, texture: any, rows: any, columns: any, textureConfig: any): any;
        function uploadMatrixToPackedTexture(gl: any, texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any, matrix: any, textureConfig: any): void;
        function uploadMatrixToTexture(gl: any, texture: any, rows: any, columns: any, matrix: any, numChannels: any, textureConfig: any): void;
        function uploadPixelDataToTexture(gl: any, texture: any, pixels: any): void;
    }
    namespace webgl_util {
        function bindCanvasToFramebuffer(gl: any): void;
        function bindColorTextureToFramebuffer(gl: any, texture: any, framebuffer: any): void;
        function bindTextureToProgramUniformSampler(gl: any, program: any, texture: any, uniformSamplerLocation: any, textureUnit: any): void;
        function bindTextureUnit(gl: any, texture: any, textureUnit: any): void;
        function bindVertexBufferToProgramAttribute(gl: any, program: any, attribute: any, buffer: any, arrayEntriesPerItem: any, itemStrideInBytes: any, itemOffsetInBytes: any): any;
        function callAndCheck(gl: any, func: any): any;
        function canBeRepresented(num: any): any;
        function checkWebGLError(gl: any): void;
        function createFragmentShader(gl: any, fragmentShaderSource: any): any;
        function createFramebuffer(gl: any): any;
        function createProgram(gl: any): any;
        function createStaticIndexBuffer(gl: any, data: any): any;
        function createStaticVertexBuffer(gl: any, data: any): any;
        function createTexture(gl: any): any;
        function createVertexShader(gl: any, vertexShaderSource: any): any;
        function enableDebugWebGLErrorChecking(enabled: any): void;
        function getBatchDim(shape: any, dimsToSkip: any): any;
        function getExtensionOrThrow(gl: any, extensionName: any): any;
        function getFramebufferErrorMessage(gl: any, status: any): any;
        function getNumChannels(): any;
        function getProgramUniformLocation(gl: any, program: any, uniformName: any): any;
        function getProgramUniformLocationOrThrow(gl: any, program: any, uniformName: any): any;
        function getRowsCols(shape: any): any;
        function getTextureShapeFromLogicalShape(logShape: any, isPacked: any): any;
        function getWebGLErrorMessage(gl: any, status: any): any;
        function isReshapeFree(shape1: any, shape2: any): any;
        function linkProgram(gl: any, program: any): void;
        function unbindColorTextureFromFramebuffer(gl: any, framebuffer: any): void;
        function unbindTextureUnit(gl: any, textureUnit: any): void;
        function validateFramebuffer(gl: any): void;
        function validateProgram(gl: any, program: any): void;
        function validateTextureSize(width: any, height: any): void;
    }
}
export function where(...args: any[]): any;
export function whereAsync(condition: any): any;
export function zeros(shape: any, dtype: any): any;
export function zerosLike(...args: any[]): any;
